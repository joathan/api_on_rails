[#chapter03-presenting-users]
= Apresentando usuários

No último capítulo, configuramos o esqueleto para a configuração dos enpoints em nossa aplicação.

Em um próximo capítulo, trataremos da autenticação do usuário através da autenticação de token, definindo permissões para definir limites de acesso, perguntando qual usuário é autenticado. Nos próximos capítulos, relacionaremos `products` (produtos) com os `users` (usuários) e forneceremos a capacidade de gerar pedidos.

Você pode clonar o projeto até este ponto com:

[source,bash]
----
$ git checkout tags/checkpoint_chapter03
----

Como você já deve estar imaginando, existem muitas soluções de autenticação para o Rails, https://github.com/binarylogic/authlogic[AuthLogic], https://github.com/thoughtbot/clearance[Clearance] e https://github.com/plataformatec/devise[Devise].

Essas bibliotecas são soluções prontas para uso, por exemplo, permitem gerenciar várias coisas, como autenticação, recuperação de senha, validação, etc. No entanto, vamos usar a gem https://github.com/codahale/bcrypt-ruby[bcrypt] para gerar um hash para a senha do usuário.

Este capítulo estará completo. Pode demorar, mas tentarei abordar o maior número possível de tópicos.
Sinta-se livre para tomar um café e vamos. No final deste capítulo, você terá construído a lógica do usuário, bem como a validação e o tratamento de erros.

É um bom momento para criar uma nova `branch` (ramificação):

[source,bash]
----
$ git checkout -b chapter03
----

NOTE: Certifique-se de estar no `branch` `master` antes de fazer _checkout_.

== Modelo de usuário

=== Gerando o modelo `Usuário` (Model User)

Começaremos gerando o nosso modelo `User`. Este modelo será realmente básico e terá apenas dois campos:

- `email`, que será único e permitirá que você se conecte a aplicação
- `password_digest` que contém a versão *hashed* da senha (discutiremos mais adiante neste capítulo)

Geramos nosso modelo `User` usando o comando _generate model_ fornecido pelo Ruby on Rails. É muito fácil de usar:

[source,bash]
----
$ rails generate model User email:string password_digest:string
invoke  active_record
      create    db/migrate/20190603195146_create_users.rb
      create    app/models/user.rb
      invoke    test_unit
      create      test/models/user_test.rb
      create      test/fixtures/users.yml
----

NOTE: O _model_ é o elemento que contém as informações ou dados, bem como a lógica relacionada a essas informações: validação, leitura e salvamento.

Este comando gera muitos arquivos! Não se preocupe, analisaremos um por um.

O arquivo de migração contido na pasta `db/migrate` contém a *migration* que descreve as alterações que você fará no banco de dados. Este arquivo pode ficar assim:


.db/migrate/20190603195146_create_users.rb
[source,ruby]
----
class CreateUsers < ActiveRecord::Migration[6.0]
  def change
    create_table :users do |t|
      t.string :email
      t.string :password_digest

      t.timestamps
    end
  end
end
----

NOTE: A data inserida no início do nome do arquivo de migração deve ser diferente para você, pois corresponde à data de criação da migração.

Faremos uma pequena alteração na migração para adicionar algumas validações ao banco de dados. Com o Rails, é prática comum fazer validações diretamente no modelo Ruby. É uma boa prática fazer isso também no esquema do banco de dados.

Portanto, faremos duas restrições adicionais:

- o email é obrigatório: usamos a propriedade `null: false`.
- email deve ser único: adicionaremos um índice para a coluna de email com a propriedade `unique: true`.
- a senha (password) é obrigatória: usamos a propriedade `null: false`.

A migração fica assim:

.db/migrate/20190603195146_create_users.rb
[source,ruby]
----
# ...
create_table :users do |t|
  t.string :email, null: false
  t.index :email, unique: true
  t.string :password_digest, null: false
  # ...
end
----

Após a conclusão da migração, podemos executar as alterações com o seguinte comando:

.db/migrate/20190603195146_create_users.rb
[source,ruby]
----
$ rake db:migrate
== 20190603195146 CreateUsers: migrating ======================================
-- create_table(:users)
   -> 0.0027s
== 20190603195146 CreateUsers: migrated (0.0028s) =============================
----

NOTE: Este comando converterá nossa migração em uma consulta SQL que atualizará o banco de dados SQLite3 armazenado na pasta _db_.

==== Modelo

Ruby on Rails provee un mecanismo completo que puedes encontrar en https://guides.rubyonrails.org/active_record_validations.html[su documentación oficial]. En nuestro caso buscamos validar solo 3 cosas:

É assim que definimos nosso esquema de banco de dados. O próximo passo é atualizar nosso modelo para definir *regras de validação*. Essas regras são definidas no modelo localizado na pasta `app/models`.

O Ruby on Rails fornece um mecanismo completo que você pode encontrar https://guides.rubyonrails.org/active_record_validations.html[na sua documentação oficial]. No nosso caso, procuramos validar apenas três coisas:

. que o email tem um formato válido
. que o email seja único
. que a senha deve ser preenchida

Essas três regras são definidas pelo seguinte código:

.app/models/user.rb
[source,ruby]
----
class User < ApplicationRecord
  validates :email, uniqueness: true
  validates_format_of :email, with: /@/
  validates :password_digest, presence: true
end
----

Ai está. O Rails usa uma sintaxe muito simples e o código é muito legível.

.Validação de email
****
Você pode perceber que a validação de email usa um método simplista
validação verificando apenas a presença de um `@`.

Isso é normal.

Existem inúmeras exceções em um endereço de email https://davidcel.is/posts/stop-validating-email-addresses-with-regex/[que até `Olhe para todos esses espaços!@example.com` é um email válido]. Portanto, é melhor fazer uma abordagem simples e confirmar o endereço de email enviando um email.
****

==== Testes unitários

Terminamos com os testes de unidade. Aqui usaremos o Minitest, uma estrutura de teste fornecida por padrão com o Rails.

O Minitest é baseado em _Fixtures_ que permitem preencher seu banco de dados com dados *predefinidos*. _Fixtures_ são definidas em um arquivo YAML no diretório `tests/fixtures`. Há um arquivo de modelo.


Portanto, devemos começar a atualizar nossos `tests/fixtures'.

NOTE: _fixtures_ não foram projetados para criar todos os dados que seus testes precisam. Eles permitem apenas definir os dados básicos de que seu aplicativo precisa.

Então começamos criando uma _fixture_ definindo um usuário:

.test/fixtures/users.yml
[source,yaml]
----
one:
  email: one@one.org
  password_digest: hashed_password
----

Agora podemos criar três testes:

- 1. Verifique se um usuário com dados corretos é válido:

.test/models/user_test.rb
[source,ruby]
----
# ...
test 'user with a valid email should be valid' do
  user = User.new(email: 'test@test.org', password_digest: 'test')
  assert user.valid?
end
----

- 2. Verifique se um usuário com um email errado não é válido:

.test/models/user_test.rb
[source,ruby]
----
# ...
test 'user with invalid email should be invalid' do
  user = User.new(email: 'test', password_digest: 'test')
  assert_not user.valid?
end
----

- 3. Verifique se um novo usuário com um email duplicado não é válido. assim usamos o mesmo email da _fixture_ que acabamos de criar.

.test/models/user_test.rb
[source,ruby]
----
# ...
test 'user with taken email should be invalid' do
  other_user = users(:one)
  user = User.new(email: other_user.email, password_digest: 'test')
  assert_not user.valid?
end
----

Aí está. Podemos validar que nossa implementação está correta simplesmente executando os testes de unidade que criamos:

[source,bash]
----
$ rake test
...
3 runs, 3 assertions, 0 failures, 0 errors, 0 skips
----

Acho que é hora de fazer um pequeno _commit_ para validar nosso progresso:

[source,bash]
----
$ git add . && git commit -m "Create user model"
----

=== Hash de senha

Anteriormente, implementamos o armazenamento de dados do usuário. Mas ainda temos um problema a resolver: *o armazenamento da senha está em texto simples*.

> Se você armazena a senha dos usuários em texto sem formatação, um invasor que rouba uma cópia do seu banco de dados possui uma lista gigante de emails e senhas. Alguns de seus usuários só podem ter uma senha - para a conta de email, a conta bancária e sua aplicação. Um simples hack pode fazer um grande roubo de identidades. - https://github.com/codahale/bcrypt-ruby#why-you-should-use-bcrypt[fonte - Por que você deve usar o bcrypt]

Então, vamos usar a gem bcrypt para *hash* da senha.

NOTE: Hash é o processo de transformar uma matriz de caracteres em um _Hash_. Este _Hash_ não permite encontrar a matriz de caracteres original. De qualquer forma, podemos usá-lo facilmente para descobrir se um determinado conjunto de caracteres corresponde ao _hash_ que armazenamos.

Primeiro devemos adicionar a gem Bcrypt ao _Gemfile_. Podemos usar o comando `bundle add`. Que vai fazer:

1. adicione a gem ao Gemfile, recuperando a versão mais recente
2. execute o comando `bundle install` que instalará o gem e atualizará o arquivo _Gemfile.lock_ "bloqueando" a versão atual da gem

Portanto, executamos o seguinte comando:

[source,bash]
----
$ bundle add bcrypt
----

Depois que o comando é executado, a seguinte linha é adicionada ao final do _Gemfile_:

[source,ruby]
.Gemfile
----
gem "bcrypt", "~> 3.1"
----

NOTE: A versão 3.1 do bcrypt é a versão atual no momento da escrita. Portanto, isso pode variar no seu caso.

O Active Record nos oferece um método https://github.com/rails/rails/blob/6-0-stable/activemodel/lib/active_model/secure_password.rb#L61[`ActiveModel::SecurePassword::has_secure_password`] que irá interagir com o Bcrypt e nos ajudará com a senha, o que facilita.

[source,ruby]
.app/models/user.rb
----
class User < ApplicationRecord
  # ...
  has_secure_password
end
----

`has_secure_password` adicione as seguintes validações:

* A senha deve estar presente na criação.
* O tamanho da senha deve ser menor ou igual a 72 bytes.
* A confirmação da senha usa o atributo `password_confirmation` (se enviado)

Além disso, este método adicionará um atributo `User#password` que será automaticamente salvo em hash no atributo `User#password_digest`.

Vamos tentar isso agora mesmo no console do Rails. Abra um console com o `rails console`:

[source,ruby]
----
2.6.3 :001 > User.create! email: 'toto@toto.org', password: '123456'
 =>#<User id: 1, email: "toto@toto.org", password_digest: [FILTERED], created_at: "2019-06-04 10:51:44", updated_at: "2019-06-04 10:51:44">
----

Você pode ver que quando você chama o método `User#create!`, O atributo `password` é um hash e salva em `password_digest`. Também enviaremos um atributo `password_confirmation` que o ActiveRecord comparará com o `password`:

[source,ruby]
----
2.6.3 :002 > User.create! email: 'tata@tata.org', password: '123456', password_confirmation: 'azerty'
ActiveRecord::RecordInvalid (Validation failed: Password confirmation doesn t match Password)
----

Tudo está funcionando como planejado! Vamos fazer um _commit_ para manter a história concisa:

[source,bash]
----
$ git commit -am "Setup Bcrypt"
----

== Criando usuários

É hora de fazer nosso primeiro "entry point" (ponto de entrada). Começaremos criando a ação `show` que responderá com informações de um único usuário no formato JSON. Os passos são:

1. gere o controlador `users_controller`.
2. adicione os testes correspondentes
3. construa o código real.

Vamos nos concentrar primeiro na geração do controlador (controller) e no teste funcional.

Para respeitar a visualização da nossa API, reduziremos nossa
aplicação usando *modules* (módulos). A sintaxe é, portanto, da seguinte maneira:

[source,bash]
----
$ rails generate controller api::v1::users
----

Este comando criará o arquivo `users_controller_test.rb`. Antes de prosseguir, há duas coisas que queremos testar em nossa API:

* A estrutura JSON retornada pelo servidor
* O código da resposta HTTP retornado pelo servidor

.Códigos HTTP mais comuns
****
O primeiro dígito do código de status especifica uma das 5 classes de resposta. O mínimo necessário para um cliente HTTP é que ele seja uma dessas 5 classes. Esta é uma lista dos códigos HTTP mais usados:

* `200`: Resposta padrão para uma solicitação HTTP bem-sucedida. Geralmente em solicitações `GET`
* `201`: A solicitação foi recebida e resulta na criação do novo recurso. Após uma solicitação `POST`
* `204`: O servidor possui uma solicitação processada com sucesso, mas nenhum conteúdo foi retornado. Isso é comum em uma solicitação `DELETE` bem-sucedida.
* `400`: A solicitação não pode ser executada devido a uma sintaxe incorreta. Isso pode acontecer para qualquer tipo de solicitação.
* `401`: semelhante ao `403`, mas especialmente usado ao solicitar autenticação e falhar ou ainda não foi fornecida autenticação. Isso pode acontecer em qualquer tipo de solicitação.
* `404`: O recurso solicitado não foi encontrado, mas pode estar disponível no futuro. Geralmente, diz respeito à solicitação `GET`.
* `500`: Uma mensagem de erro genérica, fornecida quando uma condição inesperada é encontrada e nenhuma outra mensagem específica é apropriada.

Para obter uma lista completa dos códigos HTTP, consulte este https://en.wikipedia.org/wiki/List_of_HTTP_status_codes[artigo da Wikipedia (em inglês)].
****

Portanto, vamos implementar o teste funcional que verifica o acesso ao método `Users#show`.

[source,ruby]
.test/controllers/api/v1/users_controller_test.rb
----
# ...
class Api::V1::UsersControllerTest < ActionDispatch::IntegrationTest
  setup do
    @user = users(:one)
  end

  test "should show user" do
    get api_v1_user_url(@user), as: :json
    assert_response :success
    # Test to ensure response contains the correct email
    json_response = JSON.parse(self.response.body)
    assert_equal @user.email, json_response['email']
  end
end
----


Então, basta adicionar a ação ao seu controlador. É extremamente simples:

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class  Api::V1::UsersController < ApplicationController
  # GET /users/1
  def show
    render json: User.find(params[:id])
  end
end
----

Se você executar o teste com `rails test`, receberá o seguinte erro:

[source,bash]
----
$ rails test

...E

Error:
UsersControllerTest#test_should_show_user:
DRb::DRbRemoteError: undefined method \`api_v1_user_url' for #<UsersControllerTest:0x000055ce32f00bd0> (NoMethodError)
    test/controllers/users_controller_test.rb:9:in `block in <class:UsersControllerTest>'
----

Esse tipo de erro é muito comum quando você gera seus recursos manualmente! De fato, esquecemos completamente *o caminho* (a rota). Então, vamos adicioná-lo:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  namespace :api, defaults: { format: :json } do
    namespace :v1 do
      resources :users, only: [:show]
    end
  end
end
----

Os testes agora devem passar:

----
$ rails test
....
4 runs, 5 assertions, 0 failures, 0 errors, 0 skips
----

Como de costume, depois de adicionar um dos recursos com os quais estamos satisfeitos, faça um _commit_:

[source,bash]
----
$ git add . && git commit -m "Adds show action to the users controller"
----

=== Teste seu recurso com cURL

Finalmente, temos um recurso para testar. Temos muitas soluções para testá-lo. O primeiro que vem à mente é usar o cURL, que é integrado à maioria das distribuições Linux. Então, vamos tentar:

Primeiro, inicializamos o servidor Rails em um novo terminal.
[source,bash]
----
$ rails s
----

Em seguida, volte ao seu outro terminal e execute:

[source,bash]
----
$ curl http://localhost:3000/api/v1/users/1
{"id":1,"email":"toto@toto.org", ...
----

Encontramos o usuário que criamos com o console do Rails na seção anterior. Agora você tem uma entrada na API para registro do usuário.

=== Criar usuários

Agora que entendemos melhor como criar "pontos de entrada", é hora de estender nossa API. Um dos recursos mais importantes é oferecer aos usuários que possam criar um perfil em nosso aplicativo. Como sempre, vamos escrever nossos testes antes de implementar nosso código para estender nosso conjunto de testes.

Verifique se o diretório Git está limpo e se você não possui arquivos no _staging_. Nesse caso, faça o _commit_ que vamos começar de novo.

Então, vamos começar escrevendo nosso teste adicionando uma entrada para criar um usuário no arquivo `users_controller_test.rb`:

[source,ruby]
.test/controllers/users_controller_test.rb
----
# ...
class Api::V1::UsersControllerTest < ActionDispatch::IntegrationTest
  # ...
  test "should create user" do
    assert_difference('User.count') do
      post api_v1_users_url, params: { user: { email: 'test@test.org', password: '123456' } }, as: :json
    end
    assert_response :created
  end

  test "should not create user with taken email" do
    assert_no_difference('User.count') do
      post api_v1_users_url, params: { user: { email: @user.email, password: '123456' } }, as: :json
    end
    assert_response :unprocessable_entity
  end
end
----

É muito código. Não se preocupe, eu vou explicar tudo:

* No primeiro teste, revisamos a criação de um usuário enviando uma solicitação POST válida. Portanto, verificamos se um usuário adicionado existe no banco de dados e se o código HTTP de resposta é `created`  (código de status 201)
* No segundo teste, verificamos se o usuário não foi criado usando um endereço de e-mail que já esteja em uso. Por isso, verificamos que o código HTTP de resposta é `processable_entity` (código de status 422)

Até esse ponto, o teste deve falhar (conforme o esperado):

[source,bash]
----
$ rails test
...E
----

Portanto, é hora de implementar o código para que nosso teste seja bem-sucedido:

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class Api::V1::UsersController < ApplicationController
  # ...

  # POST /users
  def create
    @user = User.new(user_params)

    if @user.save
      render json: @user, status: :created
    else
      render json: @user.errors, status: :unprocessable_entity
    end
  end

  private

  # Only allow a trusted parameter "white list" through.
  def user_params
    params.require(:user).permit(:email, :password)
  end
end
----

Lembre-se de que toda vez que adicionamos uma entrada em nossa API, devemos adicionar esta ação em nosso arquivo `routes.rb`.

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  namespace :api, defaults: { format: :json } do
    namespace :v1 do
      resources :users, only: %i[show create]
    end
  end
end
----

Como você pode ver, a implementação é bastante simples. Também adicionamos o método privado `user_params` para proteger contra a atribuição massiva de atributos. Agora nosso teste deve passar:

[source,bash]
----
$ rails test
......
6 runs, 9 assertions, 0 failures, 0 errors, 0 skips
----

sim! Vamos da um _commit_ as mudanças e continuar construindo nosso aplicativo:

[source,bash]
----
$ git commit -am "Adds the user create endpoint"
----

=== Atualizar usuários

O esquema para atualizar usuários é muito semelhante ao esquema de criação. Se você é um desenvolvedor experiente do Rails, já conhece as diferenças entre essas duas ações:

* A ação de atualização responde a uma solicitação PUT/PATCH.
* Apenas um usuário conectado poder atualizar suas informações. Isso significa que teremos que forçar um usuário a se autenticar. Discutiremos isso no capítulo 5.

Como sempre, começamos escrevendo nosso teste:

[source,ruby]
.test/controllers/users_controller_test.rb
----
# ...
class Api::V1::UsersControllerTest < ActionDispatch::IntegrationTest
  # ...
  test "should update user" do
    patch api_v1_user_url(@user), params: { user: { email: @user.email, password: '123456' } }, as: :json
    assert_response :success
  end

  test "should not update user when invalid params are sent" do
    patch api_v1_user_url(@user), params: { user: { email: 'bad_email', password: '123456' } }, as: :json
    assert_response :unprocessable_entity
  end
end
----

Para que o teste seja bem-sucedido, precisamos construir a ação de atualização no arquivo `users_controller.rb` e adicionar a rota ao arquivo `routes.rb`. Como você pode ver, temos muito código duplicado, vamos redesenhar nosso teste no capítulo 4. Primeiro, adicionamos a ação ao arquivo `routes.rb`:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # ...
  resources :users, only: %i[show create update]
  # ...
end
----

Para finalizar, implementamos a ação de atualização no controlador do usuário e executamos os testes:

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class Api::V1::UsersController < ApplicationController
  before_action :set_user, only: %i[show update]

  # GET /users/1
  def show
    render json: @user
  end

  # ...

  # PATCH/PUT /users/1
  def update
    if @user.update(user_params)
      render json: @user, status: :ok
    else
      render json: @user.errors, status: :unprocessable_entity
    end
  end

  private
  # ...

  def set_user
    @user = User.find(params[:id])
  end
end

----

Todos os nossos testes devem passar:

[source,bash]
----
$ rails test
........
8 runs, 11 assertions, 0 failures, 0 errors, 0 skips
----

Fazemos um _commit_ já que tudo funciona:

[source,bash]
----
$ git commit -am "Adds update action the users controller"
----

=== Deletar usuário

Até o momento, realizamos várias ações no controlador de usuário com estes, mas ainda não concluímos. Só precisamos de mais uma coisa, que é a açãp de excluir. Então, vamos criar o teste:

[source,ruby]
.test/controllers/users_controller_test.rb
----
# ...
class Api::V1::UsersControllerTest < ActionDispatch::IntegrationTest
  # ...

  test "should destroy user" do
    assert_difference('User.count', -1) do
      delete api_v1_user_url(@user), as: :json
    end
    assert_response :no_content
  end
end
----

Como você pode ver, o teste é muito simples. Nós respondemos apenas com o status *204*, que significa `No Content` (Sem conteúdo). Também podemos retornar um código de status *200*, mas acho a resposta `No Content` mais natural nesse caso, porque excluimos um recurso e uma resposta bem-sucedida pode ser o bastante.

A implementação da ação de exclusão é muito simples:

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class Api::V1::UsersController < ApplicationController
  before_action :set_user, only: %i[show update destroy]
  # ...

  # DELETE /users/1
  def destroy
    @user.destroy
    head 204
  end

  # ...
end
----

Não se esqueça de adicionar a ação `destroy` no arquivo `routes.rb`:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # ...
  resources :users, only: %i[show create update destroy]
  # ...
end
----

Os testes devem passar se tudo estiver correto:

[source,bash]
----
$ rails test
.........
9 runs, 13 assertions, 0 failures, 0 errors, 0 skips
----

Lembre-se de que, após fazer algumas alterações em nosso código, é uma boa prática fazer _commit_ para que possamos ter um histórico adequadamente segmentado.

[source,bash]
----
$ git commit -am "Adds destroy action to the users controller"
----

E quando chegamos ao final do nosso capítulo, é hora de aplicar nossas modificações a `branch master`, fazendo um _merge_:

[source,bash]
----
$ git checkout master
$ git merge chapter03
----

== Conclusão

Oh, aí está, muito bem! Eu sei que provavelmente demorou muito tempo, mas não desista! Certifique-se de entender cada parte do código, as coisas vão melhorar. No próximo capítulo, vamos redesenhar nossos testes para tornar nosso código mais legível e sustentável. Então fique comigo!
