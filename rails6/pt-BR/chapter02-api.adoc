[#chapter02-api]
= A API

Nesta seção, resumirei o aplicativo. Até agora você deveria ter lido o capítulo anterior. Se você ainda não o leu, recomendo que você o faça.

Você pode clonar o projeto até este ponto com:

[source,bash]
----
$ git checkout tags/checkpoint_chapter02
----

Em resumo, simplesmente geramos nossa aplicação Rails e fizemos o primeiro commit.

== Planejando o aplicativo

Como queremos que o aplicativo seja simples, ele será composto por 5 modelos. Não se preocupe se você não entender completamente o que estamos fazendo. Analisaremos e criaremos cada um dos recursos à medida que avançamos no tutorial.

image:data_model.png[Esquema de relacionamento entre modelos]

Em resumo, o `user`(usuário) poderá fazer muitas `orders`(pedidos), fazer upload de vários `produtos` que podem ter muitas `images` (imagens) ou `comments` (comentários) de outros usuários do aplicativo.

Não criaremos visualizações para exibir ou interagir com a API. Portanto, não faça deste um ótimo tutorial. Para isso, existem muitas opções por aí, como os frameworks javascript (https://angularjs.org/[Angular], https://vuejs.org/[Vue.js], https://reactjs.org/[React.js]).


Até este ponto, você deve se perguntar:

> Ok, mas preciso explorar ou visualizar como está indo a construção da API, como farei isso?

Isso é justo. Provavelmente, se você pesquisar no Google algo relacionado à exploração de APIs, um aplicativo chamado https://www.getpostman.com/[Postman] será exibido. É um ótimo software, mas de qualquer maneira, não usaremos isso porque usaremos *cURL* que permite a qualquer pessoa reproduzir a solicitação em qualquer computador.

== Configurando a API

Uma API é definida pela http://en.wikipedia.org/wiki/Application_programming_interface[wikipedia] como uma interface de programação de aplicativos (API) especifica como alguns componentes de software devem interagir entre si. Em outras palavras, a maneira como os sistemas interagem entre si através de uma interface comum, no nosso caso, um serviço web construído com JSON.Existem outros tipos de protocolos de comunicação como SOAP, mas nós não estamos cobrindo isso aqui.

JSON, como padrão de tipo de mídia da Internet, é amplamente aceito, legível, extensível e fácil de implementar. Muitas das atuais estruturas consomem APIs JSON por padrão (https://angularjs.org/[Angular] ou https://vuejs.org/[Vue.js] por exemplo). Também existem ótimas bibliotecas para Objective-C, como https://github.com/AFNetworking/AFNetworking[AFNetworking] ou http://restkit.org/[RESTKit]. Provavelmente existem boas soluções para Android mas por causa da minha falta de experiência nessa plataforma de desenvolvimento eu posso não ser a pessoa certa para recomendar alguma coisa.

Tudo certo. Então, estamos construindo nossa API com JSON. Existem muitos caminhos para alcançar isto. A primeira coisa que vem à mente seria apenas comece a adicionar rotas definindo os end points. Isso pode ser ruim porque eles podem não ter um http://www.w3.org/2005/Incubator/wcl/matching.html[padrão de URI] claro o suficiente para saber qual recurso está sendo exposto. O protocolo ou estrutura que estou falando é http://en.wikipedia.org/wiki/Representational_state_transfer[REST] que significa Representational State Transfer(Transferência Representacional de Estado) seguindo a definição da wikipedia.

[source,soap]
----
aService.getUser("1")
----

E no REST, você pode chamar um URL com uma solicitação HTTP específica, neste caso com uma solicitação GET: <http://domain.com/resources_name/uri_pattern>

As APIs RESTful devem seguir pelo menos três diretrizes simples:

* Uma base http://en.wikipedia.org/wiki/Uniform_resource_identifier[URI], como `http://example.com/resources/`.
* Um tipo de Internet multimídia para representar dados, geralmente é JSON e geralmente definido pela troca de cabeçalhos.
* Siga os http://en.wikipedia.org/wiki/HTTP_method#Request_methods[métodos HTTP] padrão, como GET, POST, PUT, DELETE.
** *GET*: leia o recurso ou recursos definidos pelo padrão URI
** *POST*: crie uma nova entrada na coleção de recursos
** *PUT*: atualiza uma coleção ou membro de recurso
** *DELETE*: destrói um membro de coleção ou recurso

Isso pode não estar claro o suficiente ou pode parecer muita informação para digerir, mas à medida que avançamos no tutorial, espero que fique muito mais fácil de entender.

=== Rotas, Restrições e Namespaces

Antes de começar a digitar qualquer código, preparamos o código com git. Estaremos usando uma ramificação (branch) por capítulo, faça o upload para o GitHub e mescle-o (merge) com a master. Então, vamos começar abrindo o terminal, `cd` para o diretório `market_place_api` e digite o seguinte:

[source,bash]
----
$ git checkout -b chapter02
Switched to a new branch 'chapter02'
----

Nós iremos trabalhar apenas no `config/routes.rb`, como estamos apenas definindo as restrições e o formato de resposta padrão para cada pedido.

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # ...
end
----

Antes de tudo, apague todo o código comentado que vem dentro do arquivo, nós não vamos precisar disso. Em seguida, faça um commit, como um aquecimento:

[source,bash]
----
$ git add config/routes.rb
$ git commit -m "Removes comments from the routes file"
----

Vamos isolar os controllers (controladores) da api em um namespace. Com Rails, isso é bastante simples: você apenas precisa criar uma pasta em `app/controllers` chamada `api`. O nome é importante porque esse é o namespace que usaremos para gerenciar os controllers da API e endpoints.

[source,bash]
----
$ mkdir app/controllers/api
----

Em seguida, adicionamos esse namespace em nosso arquivo _routes.rb_:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # Api definition
  namespace :api do
    # We are going to list our resources here
  end
end
----

Por definición un espacio de nombres en el archivo `routes.rb`. Rails automáticamente mapeara que espacio de nombres corresponde al folder de los _controlladores_, en nuestro caso el directorio `api/``.

Definindo um namespace no arquivo `routes.rb`. Rails mapeia automaticamente esse namespace para um diretório que corresponde ao nome
da pasta _controllers_, no nosso caso o diretório `api/`.

.Tipos de mídia Rails suportados
****
O Rails suporta 34 tipos diferentes de arquivos multimídia. Você pode listá-los acessando a classe SET do módulo Mime:

[source,bash]
----
$ rails c
2.6.3 :001 > Mime::SET.collect(&:to_s)
 => ["text/html", "text/plain", "text/javascript", "text/css", "text/calendar", "text/csv", "text/vcard", "text/vtt", "image/png", "image/jpeg", "image/gif", "image/bmp", "image/tiff", "image/svg+xml", "video/mpeg", "audio/mpeg", "audio/ogg", "audio/aac", "video/webm", "video/mp4", "font/otf", "font/ttf", "font/woff", "font/woff2", "application/xml", "application/rss+xml", "application/atom+xml", "application/x-yaml", "multipart/form-data", "application/x-www-form-urlencoded", "application/json", "application/pdf", "application/zip", "application/gzip"]
----
****

Isso é importante porque vamos trabalhar com JSON, um dos http://en.wikipedia.org/wiki/Internet_media_type[tipos MIME] internos aceitos pelo Rails, então precisamos apenas definir este formato como padrão:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # Api definition
  namespace :api, defaults: { format: :json }  do
    # We are going to list our resources here
  end
end
----

Até este momento, não fizemos nada louco. O que queremos gerar é uma _base_uri_ que inclui a versão da API. Mas vamos fazer um commit antes de ir para a próxima seção:

[source,bash]
----
$ git add config/routes.rb
$ git commit -m "Set the routes constraints for the api"
----

== Controle de versão da API

Neste ponto, devemos ter um bom mapeamento de rotas usando um namespace.
Seu arquivo `routes.rb` deve ficar assim:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # Api definition
  namespace :api, defaults: { format: :json }  do
    # We are going to list our resources here
  end
end
----

Agora é hora de configurar outras constraints (restrições) para controle de versão. Você deve se importar em versionar sua aplicação desde inicio, pois isso dará uma estrutura melhor à sua api, e quando precisam ser feitas mudanças, você pode dar aos desenvolvedores que estão consumindo sua API a oportunidade de se adaptar aos novos recursos enquanto os antigos estão sendo preteridos. Existe um excelente http://railscasts.com/episodes/350-rest-api-versioning[railscast] explicando isso.

Para definir a versão da API, primeiro precisamos adicionar outro
diretório sob a `api` que criamos:

[source,bash]
----
$ mkdir app/controllers/api/v1
----

Dessa forma, podemos nomear nossa API em diferentes versões com muita facilidade, agora só precisamos adicionar o código necessário ao arquivo `routes.rb`:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # Api definition
  namespace :api, defaults: { format: :json }  do
    namespace :v1 do
      # We are going to list our resources here
    end
  end
end
----

Nesse ponto, a API agora tem um escopo definido pela URL. Por exemplo, com a configuração atual, um endpoint para recuperar um produto seria algo como: <http://localhost:3000/v1/products/1>

.Patrones Comunes del API
****

Você pode encontrar muitas abordagens para configurar a _base_uri_ ao criar uma API seguindo padrões diferentes, assumindo que estamos fazendo versionamento na nossa API:

* `api.example.com/`: Na minha opinião, este é o caminho a seguir, oferece uma melhor interface e isolamento e, a longo prazo, pode ajudá-lo a http://www.makeuseof.com/tag/optimize-your-dns-for-faster-internet/[escalar rápidamente]
* `example.com/api/`: esse padrão é muito comum e atualmente é um bom caminho a percorrer quando você não deseja colocar sua API em um subdomínio no namespace.
* `example.com/api/v1`: Parece uma boa ideia, colocar a versão da API através da URL, parece um padrão descritivo, mas esse formulário obriga a incluir a URL em todas as solicitações, portanto, se você decidir alterar esse padrão se torna um problema de manutenção a longo prazo.

Aqui estão algumas práticas na criação de uma API que recomendam não versionar a API por meio da URL. É verdade. O desenvolvedor não deve saber a versão que você está usando. Em termos de simplicidade, decidi deixar esta convenção, que podemos aplicar em uma segunda fase.
****

É hora de fazer _commit_:

[source,bash]
----
$ git commit -am "Set the versioning namespaces for API"
----

Estamos no final do capítulo. Portanto, é hora de aplicar nossas modificações a branch master, fazendo um _merge_. Para fazer isso, mudamos para branch `master` e fazemos _merge_ do `chapter02`:

[source,bash]
----
$ git checkout master
$ git merge chapter02
----

== Conclusão

Já foi um longo caminho, eu sei, mas você conseguiu, não desista, isso é
apenas nosso pequeno passo para algo grande, então continue assim. Enquanto isso, e se você estiver curioso, existem algumas gems que lidam com tipos de configurações:

* https://github.com/Sutto/rocket_pants[RocketPants]
* https://github.com/bploetz/versionist[Versionist]

Não abordarei isso neste livro, pois estamos tentando aprender como implementar esse tipo de funcionalidade, mas é bom saber. Aliás, o código até o momento esta https://github.com/madeindjs/market_place_api_6/releases/tag/checkpoint_chapter[aqui].
